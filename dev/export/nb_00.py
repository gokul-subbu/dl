
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/00_df.ipynb

from pathlib import Path
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

pd.pandas.set_option('display.max_columns', None)
Path.ls=lambda x: list(x.iterdir())

def add_datepart(df:pd.DataFrame, cols:list=None, just_date:bool=True,inplace:bool=True)->pd.DataFrame:
    '''parameters:
                df: pd.DataFrame
                cols: datetime cols
                just date: bool specifying whether the object is it just date or date time
                inplace: bool'''
    date_part=['year','month','day','week','dayofweek','weekday','quarter','is_month_start','is_month_end','is_year_end']
    time_part=['time','hour','minute','second']
    for i in cols:
        if not just_date:
            for j in time_part:
                df[f'{i}_{j}']=getattr(df[i].dt,j)
        for j in date_part:
            df[f'{i}_{j}']=getattr(df[i].dt,j)
    df.drop(columns=cols, inplace=True)
    return

def split_val(df:pd.DataFrame, val_pct:float=0.3):
    'returns `df_train` and `df_valid`'
    shuf_idx=np.random.permutation(len(df))
    train_idx, val_idx=shuf_idx[int(val_pct*len(df)):], shuf_idx[:int(val_pct*len(df))]
    return df.iloc[train_idx,:], df.iloc[val_idx,:]

def split_dep_col(df:pd.DataFrame, y:str):
    'returns `x` and `y`'
    return df.drop(columns=y), df.loc[:, y]

def split_test_val(df:pd.DataFrame, y:str, val_pct:float=0.3):
    ''' df 'pandas datadrame object `y` is the dependent column val_pct:=0.3'
    returns `x_train`, `y_train`, `x_valid`, `y_valid`'''
    df_train, df_val= split_val(df, val_pct)
    return split_dep_col(df_train, y), split_dep_col(df_val, y)

def check_missing(df:pd.DataFrame, top:int=10):
    return pd.DataFrame(df.isna().mean()).sort_values(by=0, ascending=False)[:top]

class Tabular:
    def __init__(self, df_train:pd.DataFrame, df_val:pd.DataFrame , cat_cols:list=[], num_cols:list=[]):
        self.df_train=df_train.copy()
        self.df_val=df_val.copy()
        self.cat_cols=cat_cols
        self.num_cols=num_cols
        self.cat_col_dict={}
        self.rev_cat={}

    def conv_cat(self):
        for i in self.cat_cols:
            self.cat_col_dict[i]={k: j for j, k in enumerate(self.df_train[i].unique())}
            self.df_train[i].replace(self.cat_col_dict[i])
            self.df_val[i].replace(self.cat_col_dict[i])

    def impute_mean(self):
        self.mean_impute_dict={}
        for i in self.num_cols:
            self.mean_impute_dict[i]=self.df_train[i].mean()
            self.impute_na(self.df_train, i, self.mean_impute_dict[i])
            self.impute_na(self.df_val, i, self.mean_impute_dict[i])

    def impute_median(self):
        self.median_impute_dict={}
        for i in self.num_cols:
            self.median_impute_dict[i]=self.df_train[i].median()
            self.impute_na(self.df_train, i, self.median_impute_dict[i])
            self.impute_na(self.df_val, i, self.median_impute_dict[i])

    def impute_na(self, df:pd.DataFrame, col:str, value):
        df[col].fillna(value, inplace=True)

    def encode_disc(self):
        for i in self.dis_cols:
            df[i]=pd.qcut(df[i], 4)

    def ret_cat_codes(self):
        for i in self.cat_cols:
            self.df_train[i]=self.df_train[i].replace(self.cat_col_dict[i])
            self.impute_na(self.df_train, i, len(self.cat_col_dict[i])+1)
            self.df_val[i]=self.df_val[i].replace(self.cat_col_dict[i]) # dict(map(reversed, my_map.items()))
            self.impute_na(self.df_val, i, len(self.cat_col_dict[i])+1)

def proc_df(df_tr:pd.DataFrame, df_va:pd.DataFrame, cat_cols:list, num_cols:list):
    data=Tabular(df_tr, df_va, cat_cols=cat_cols, num_cols=num_cols)
    data.impute_mean()
    data.conv_cat()
    data.ret_cat_codes()
    return data