
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/01_nn.ipynb

from export.nb_00 import *
from torch import nn, optim, tensor, Tensor, hub
import torch.nn.functional as F
from torch.utils.data import DataLoader, SequentialSampler, RandomSampler
import gzip, pickle, torch
from tqdm.notebook import tqdm, trange


mnist_path=Path(r'd:\datasets\data\mnist.pkl.gz')
# mnist_path.ls()

def get_mnist():
    with gzip.open(mnist_path, 'rb') as f:
        ((x_train, y_train),(x_valid, y_valid), _)=pickle.load(f, encoding='latin-1')
    x_train, y_train, x_valid, y_valid= map(tensor, (x_train, y_train, x_valid, y_valid))
    return (x_train, y_train), (x_valid, y_valid)

class Dataset():
    def __init__(self, x, y):
        self.x, self.y=x, y

    def __getitem__(self, i): return self.x[i], self.y[i]
    def __len__(self): return len(self.x)

def collate(b):
    xs,ys = zip(*b)
    return torch.stack(xs),torch.stack(ys)

class Lambda(nn.Module):
    def __init__(self, func):
        super().__init__()
        self.func=func

    def forward(self, x): return self.func(x)